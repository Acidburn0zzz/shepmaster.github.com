<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Jake Goulding]]></title>
  <link href="http://jakegoulding.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://jakegoulding.com/"/>
  <updated>2013-01-16T20:50:37-05:00</updated>
  <id>http://jakegoulding.com/</id>
  <author>
    <name><![CDATA[Jake Goulding]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A little dip into Ruby's Marshal format]]></title>
    <link href="http://jakegoulding.com/blog/2013/01/15/a-little-dip-into-rubys-marshal-format/"/>
    <updated>2013-01-15T20:00:00-05:00</updated>
    <id>http://jakegoulding.com/blog/2013/01/15/a-little-dip-into-rubys-marshal-format</id>
    <content type="html"><![CDATA[<p>I recently tried to resolve a JRuby <a href="https://github.com/jruby/jruby/issues/456">issue involving Marshal</a>.
I've used <a href="http://www.ruby-doc.org/core-1.9.3/Marshal.html">Marshal</a> before, but never needed to pay attention
to the actual bytes written to disk. I decided to write up what I
learned in the process.</p>

<!-- more -->


<h2>Version number</h2>

<p><div class='bogus-wrapper'><notextile><pre><span style='color: red'>0</span><span style='color: red'>4</span><span style='color: #8FF'>0</span><span style='color: #8FF'>8</span></pre></notextile></div></p>

<p>I collected this data using Ruby 1.9.3p327, which has Marshal version
4.8. The version number is encoded with two bytes, one each for the
major and minor version. This version number precedes all dumps and
I'll ignore it for the rest of this post.</p>

<h2>Nil, true, false</h2>

<p><code>nil</code>
<div class='bogus-wrapper'><notextile><pre>0408 <span style='color: red'>3</span><span style='color: red'>0</span></pre></notextile></div>
The typecode <code>30</code> is ASCII <code>0</code>.</p>

<p><code>true</code>
<div class='bogus-wrapper'><notextile><pre>0408 <span style='color: red'>5</span><span style='color: red'>4</span></pre></notextile></div>
The typecode <code>54</code> is ASCII <code>T</code>.</p>

<p><code>false</code>
<div class='bogus-wrapper'><notextile><pre>0408 <span style='color: red'>4</span><span style='color: red'>6</span></pre></notextile></div>
The typecode <code>46</code> is ASCII <code>F</code>.</p>

<h2>Integers (easy)</h2>

<p><code>0</code>
<div class='bogus-wrapper'><notextile><pre>0408 <span style='color: red'>6</span><span style='color: red'>9</span><span style='color: #8FF'>0</span><span style='color: #8FF'>0</span></pre></notextile></div></p>

<p>The typecode <code>69</code> is ASCII <code>i</code>. The typecode is followed by the value
of the integer. Zero is represented as <code>00</code>.</p>

<p><code>1</code>
<div class='bogus-wrapper'><notextile><pre>0408 69<span style='color: #8FF'>0</span><span style='color: #8FF'>6</span></pre></notextile></div></p>

<p>Here we see that the encoded value for one is <code>06</code>, not <code>01</code> as we
might expect at first. This allows for more efficient storage of
smaller numbers. -123 &lt;= x &lt;= 122 can be encoded in just one byte.</p>

<h2>Arrays</h2>

<p><code>[]</code>
<div class='bogus-wrapper'><notextile><pre>0408 <span style='color: red'>5</span><span style='color: red'>b</span><span style='color: #8FF'>0</span><span style='color: #8FF'>0</span></pre></notextile></div></p>

<p>The typecode <code>5b</code> is ASCII <code>[</code>. The typecode is followed by the
number of elements in the array.</p>

<p><code>[1]</code>
<div class='bogus-wrapper'><notextile><pre>0408 5b<span style='color: #8FF'>0</span><span style='color: #8FF'>6</span> <span style='color: #CC0'>6</span><span style='color: #CC0'>9</span><span style='color: #CC0'>0</span><span style='color: #CC0'>6</span></pre></notextile></div></p>

<p>The number of items in the array is encoded in the same form as
integers. Each value in the array is encoded sequentially after the
size of the array.</p>

<h2>Hashes</h2>

<p><code>{}</code>
<div class='bogus-wrapper'><notextile><pre>0408 <span style='color: red'>7</span><span style='color: red'>b</span><span style='color: #8FF'>0</span><span style='color: #8FF'>0</span></pre></notextile></div>
The typecode <code>7b</code> is ASCII <code>{</code>. The typecode is followed by the number
of (key, value) pairs in the hash.</p>

<p><code>{1 =&gt; 2}</code>
<div class='bogus-wrapper'><notextile><pre>0408 7b<span style='color: #8FF'>0</span><span style='color: #8FF'>6</span> <span style='color: #CC0'>6</span><span style='color: #CC0'>9</span><span style='color: #CC0'>0</span><span style='color: #CC0'>6</span> <span style='color: #0C0'>6</span><span style='color: #0C0'>9</span><span style='color: #0C0'>0</span><span style='color: #0C0'>7</span></pre></notextile></div></p>

<p>Like arrays, the number of items in the hash is encoded in the same
form as integers. Each pair of (key, value) is encoded sequentially
after the size of the hash.</p>

<h2>Symbols</h2>

<p><code>:hello</code>
<div class='bogus-wrapper'><notextile><pre>0408 <span style='color: red'>3</span><span style='color: red'>a</span><span style='color: #8FF'>0</span><span style='color: #8FF'>a</span> <span style='color: #CC0'>6</span><span style='color: #CC0'>8</span><span style='color: #CC0'>6</span><span style='color: #CC0'>5</span> <span style='color: #CC0'>6</span><span style='color: #CC0'>c</span><span style='color: #CC0'>6</span><span style='color: #CC0'>c</span> <span style='color: #CC0'>6</span><span style='color: #CC0'>f</span></pre></notextile></div></p>

<p>The typecode <code>3a</code> is ASCII <code>:</code>. The typecode is followed by the length
of the symbol name and then the symbol name itself, encoded as UTF-8.</p>

<h2>Symlinks</h2>

<p>When a symbol is repeated multiple times, the Marshal encoding allows
subsequent instances to reference the first instance to save space in
the stream.</p>

<p><code>[:hello, :hello]</code>
<div class='bogus-wrapper'><notextile><pre>0408 5b07 <span style='color: #8FF'>3</span><span style='color: #8FF'>a</span><span style='color: #8FF'>0</span><span style='color: #8FF'>a</span> <span style='color: #8FF'>6</span><span style='color: #8FF'>8</span><span style='color: #8FF'>6</span><span style='color: #8FF'>5</span> <span style='color: #8FF'>6</span><span style='color: #8FF'>c</span><span style='color: #8FF'>6</span><span style='color: #8FF'>c</span> <span style='color: #8FF'>6</span><span style='color: #8FF'>f</span><span style='color: red'>3</span><span style='color: red'>b</span> <span style='color: #CC0'>0</span><span style='color: #CC0'>0</span></pre></notextile></div></p>

<p>The typecode <code>3b</code> is ASCII <code>;</code>.  The typecode is followed by the
position of the symbol in the cache table. This table is indexed by
the order in which the symbol first appeared.</p>

<h2>The rest</h2>

<p>There's a lot more to the Marshal format; I haven't even covered
strings yet! I'll need to create another post to address the rest.</p>

<h2>How to explore on your own</h2>

<p>To generate the examples for this post, I hacked up a quick helper in
irb:</p>

<p><code>ruby
def dump(x)
  File.open('/tmp/out', 'w') {|f| Marshal.dump(x, f)}
  `xxd /tmp/out`
end
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Attaching top-level methods to an object in Ruby]]></title>
    <link href="http://jakegoulding.com/blog/2012/03/03/attaching-top-level-methods-to-an-object-in-ruby/"/>
    <updated>2012-03-03T10:48:00-05:00</updated>
    <id>http://jakegoulding.com/blog/2012/03/03/attaching-top-level-methods-to-an-object-in-ruby</id>
    <content type="html"><![CDATA[<p>Sometimes when you are doing rapid development, you need to create a
new method <em>right now</em>, but you don't put the method in the right
spot. Maybe you aren't sure what object should ultimately have the
functionality. Maybe you are simply too lazy to open the correct
file. Whatever the reason, you decide to define the method right there
at the top-level, pretending you are a procedural programmer.</p>

<!-- more -->


<p>Time passes, and you finally decide it is time to move that method to
where it belongs. The problem is that someone (certainly not you...)
has been calling that method from <em>everywhere</em>. Fixing all the calls
to the method at once will be a huge change; you prefer to make
smaller, easier to review changes. Or maybe you don't have control
over all code that calls the method, and so you <em>can't</em> change all the
the calls.</p>

<p>Here's an example of the problem</p>

<p>```ruby
def add_value(object, param)
  object.value + param
end</p>

<p>class MyObject
  def value</p>

<pre><code>10
</code></pre>

<p>  end
end</p>

<p>obj = MyObject.new
add_value(obj, 5)
```</p>

<p>You'd really like <code>MyObject</code> to have an <code>add_value</code> method, instead of
it just floating around at the top-level. However, you don't want to
just copy code around - what if one of the implementations changes?
Your first instinct might be to do something like this:</p>

<p>```ruby
class MyObject
  def add_value(param)</p>

<pre><code>add_value(self, param)
</code></pre>

<p>  end
end
```</p>

<p>The problem with this is that once you are inside the class
definition, all calls to <code>add_value</code> will be handled by the instance,
not the top-level method.</p>

<p>You could avoid this by making the top-level method and the instance
method have unique names. If you like the existing name for both
methods, you could alias the original name to a more unique one to
avoid shadowing it:</p>

<p>```ruby
alias :i_am_secret_method_add_value :add_value</p>

<p>class MyObject
  def add_value(param)</p>

<pre><code>i_am_secret_method_add_value(self, param)
</code></pre>

<p>  end
end
```</p>

<p>Another solution is to qualify access to the top-level method. This
can be done by maintaining a reference to the object that defines the
method.</p>

<p>```ruby
reference_to_main = self                            # 1
MyObject.class_eval do                              # 2
  define_method :add_value do |param|</p>

<pre><code>reference_to_main.send(:add_value, self, param) # 3
</code></pre>

<p>  end
end
```</p>

<ol>
<li>We start by stashing a reference to the object that defines the
top-level method. This object is named "main".</li>
<li>If we reopened our class the traditional way, using <code>class MyObject</code>,
the reference to main would fall out of scope. Instead, we use
<code>class_eval</code>.</li>
<li>The definition of the <code>add_value</code> instance method must use <code>send</code> as
the top-level method is private.</li>
</ol>


<p>If you don't want to modify the object directly, you can apply the
same techniques to a module:</p>

<p>```ruby
module MathModule
end</p>

<p>reference_to_main = self
MathModule.module_eval do
  define_method :add_value do |param|</p>

<pre><code>reference_to_main.send(:add_value, self, param)
</code></pre>

<p>  end
end</p>

<p>obj = MyObject.new
obj.extend(MathModule)
```</p>

<p>Using modules leads to another solution. You can move the top-level
method into a module, and use the module with both the class and the
main object.</p>

<p>```ruby
module MathModule
  def add_value(object, param)</p>

<pre><code>object.value + param
</code></pre>

<p>  end
end</p>

<p>extend MathModule</p>

<p>class MyObject
  include MathModule</p>

<p>  def add_value(param)</p>

<pre><code>super(self, param)
</code></pre>

<p>  end
end
```</p>

<p>The downside to this solution is that the object now has two
<code>add_value</code> methods. One of the methods takes any instance of the
class, which would be confusing to anyone trying to figure out how to
use the object.</p>

<p>The easiest and clearest solution to this problem is not to use clever
metaprogramming, but just flip the way you think about the
problem. Move the entire method into the object and leave a stub
method that redirects to the object's implementation:</p>

<p>```ruby
def add_value(object, param)
  object.add_value(param)
end</p>

<p>class MyObject
  def add_value(param)</p>

<pre><code>value + param
</code></pre>

<p>  end
end
```</p>
]]></content>
  </entry>
  
</feed>
